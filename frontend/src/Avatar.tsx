// src/Avatar.tsx
import React, { useEffect, useRef } from "react";
import { useGLTF } from "@react-three/drei";
import * as THREE from "three";

/* --------------------------------------------------------------
   Map from phoneme names (Rhubarb) to the blend‑shape index used
   by the Ready‑Player‑Me model. Adjust if you use a different avatar.
-------------------------------------------------------------- */
const blendMap: Record<string, number> = {
  AA: 1,
  I: 2,
  U: 3,
  E: 4,
  O: 5,
  M: 6,
  B: 7,
  F: 8,
  L: 9,
  Rest: 0,
};

type Viseme = { time: number; value: string };

interface Props {
  /** Relative URL that points to a .glb stored in `frontend/public/` */
  modelUrl: string;
  /** Array of viseme cues generated by the backend */
  visemes: Viseme[];
  /** Optional manual scale – default = 1 (the component already auto‑fits) */
  extraScale?: number;
}

/* --------------------------------------------------------------
   Helper – walk the hierarchy and return the first Mesh that has
   a non‑empty `morphTargetInfluences` array (i.e. blend‑shapes).
-------------------------------------------------------------- */
function findFirstMeshWithBlendShapes(root: THREE.Object3D): THREE.Mesh | undefined {
  let found: THREE.Mesh | undefined;

  root.traverse((obj) => {
    if ((obj as THREE.Mesh).isMesh) {
      const mesh = obj as THREE.Mesh;
      if (Array.isArray(mesh.morphTargetInfluences) && mesh.morphTargetInfluences.length > 0) {
        found = mesh;
      }
    }
  });

  return found;
}

/* ==============================================================
   Avatar component
   ============================================================== */
export default function Avatar({
  modelUrl,
  visemes,
  extraScale = 1,
}: Props) {
  /* ---------- 1️⃣ Load the GLB (cached by Drei) ---------- */
  const { scene } = useGLTF(modelUrl); // no extra boolean argument needed

  /* ---------- 2️⃣ Find a mesh that actually has blend‑shapes ---------- */
  const meshRef = useRef<THREE.Mesh | null>(null);
  useEffect(() => {
    const found = findFirstMeshWithBlendShapes(scene);
    if (found) {
      meshRef.current = found;
      console.log("✅ Avatar – blend‑shape mesh found:", found.name);
    } else {
      meshRef.current = null;
      console.warn(
        "⚠️ Avatar – no mesh with morphTargetInfluences; a static model will be shown."
      );
    }
  }, [scene]);

  /* ---------- 3️⃣ Auto‑center & auto‑scale the whole scene ---------- */
  useEffect(() => {
    const box = new THREE.Box3().setFromObject(scene);
    const size = box.getSize(new THREE.Vector3()).length();

    // Fit the model into a 2‑unit cube (you can change 2 → any size you prefer)
    const autoScale = size === 0 ? 1 : 2 / size;
    scene.scale.setScalar(autoScale * (extraScale ?? 1));

    // Move the centre of the model to the world origin (0,0,0)
    const center = box.getCenter(new THREE.Vector3());
    scene.position.sub(center);
  }, [scene, extraScale]);

  /* ---------- 4️⃣ Lip‑sync animation (only runs if we have a blend‑shape mesh ---------- */
  useEffect(() => {
    if (!visemes.length || !meshRef.current) return;

    const start = performance.now() / 1000;
    const tick = () => {
      const now = performance.now() / 1000 - start;

      // pick the most recent cue whose time <= now
      const cue = visemes
        .filter((c) => c.time <= now)
        .reduce(
          (prev, cur) => (cur.time > prev.time ? cur : prev),
          { time: -1, value: "Rest" }
        );

      const idx = blendMap[cue.value] ?? blendMap["Rest"];
      const mesh = meshRef.current!;
      mesh.morphTargetInfluences!.fill(0);
      mesh.morphTargetInfluences![idx] = 1;

      requestAnimationFrame(tick);
    };
    tick(); // start the animation loop
  }, [visemes]);

  /* ---------- 5️⃣ Render the scene + a tiny AxesHelper (helps debugging) ---------- */
  return (
    <>
      <primitive object={scene} />
      {/* AxesHelper draws red‑X, green‑Y, blue‑Z axes at the world origin */}
      <axesHelper args={[1]} />
    </>
  );
}
